# 1 Care and feeding of iptables

This chapter covering essential aspects of properly installing, maintaining, and interacting with the iptables firewall on Linux systems. Also , aspects such as iptables administration from the perspectives of both kernel and userland, as well as how to build and maintain an iptables firewall policy. 

## 1.1 iptables

The iptables firewall is developed by Netfilter Project and has been available to the masses as part of Linux since the release of the Linux 2.4 kernel in January 2001.

The differences between the terms *iptables* and *Netfilter* have been a source of some confusion in the Linux community. To reduce the complexity, think them as follow:

 - Netfilter: providing the framework on which *iptables* builds firewall functionality.
 - iptables: refers to the userland tool that parses the command line and communicates a firewall policy to the kernel.

Terms such as *tables* , *chains* , *matches* , and *targets* make sense in the context of iptables.

Netfilter does not filter traffic itself--it just allows functions that *can* filter traffic to be hooked into the right spot within the kernel. The Netfilter Project also provides serveral pieces of infrastructure in the kernel, such as connection tracking and logging; any iptables policy can use these facilities to perform specialized packet processing.

## 1.2 Packet Filtering with iptables

An iptables policy is built from an ordered set of *rules* , which describe to the kernel the actions that should be taken against certain classes of packets. Each iptables rule is applied to a chain within a table.  **An iptables *chain* is a collection of rules that are compared , in order , against packets that share a common characteristic (such as being routed to the Linux system, as opposed to away from it.)**

### 1.2.1 Tables

A *table* is an iptables construct that delineates broad categories of functionality, such as packet filtering or Network Address Translation(NAT). There are four tables: **filter** , **nat** , **mangle** , and **raw** .

Filtering rules are applied to the filter table.

NAT rules are applied to the nat table.

Specialized rules that alter packet data are applied to the mangle table.

Rules that should function independently of the Netfilter connection-tracking subsystem are applied to the raw table.

### 1.2.2 Chains

Each table has its own set of built-in chains, but user-defined chains can also be created so that the user can build a set of rules that is related by a common tag such as **INPUT_ESTABLISHED** or **DMZ_NETWORK** . The most important built-in chains for our purposes are the **INPUT** , **OUTPUT** , and **FORWARD** chains in the filter table:

- The **INPUT** chain is traversed by packets that are **destined for the local Linux system after a routing calculation is made within the kernel(i.e., packets destined for a local socket)**.
- The **OUTPUT** chain is reserved for packets that are **generated by the Linux system itself**.
- The **FORWARD** chain governs packets that are **routed through the Linux system(i.e., when the iptables firewall is used to connect one network to another and packets between the two networks must flow through the firewall)**.

Two additional chains that are important for any serious iptables deployment are the **PREROUTING** and **POSTROUTING** chains in the nat table, which are **used to modify packet headers before and after an IP routing calculation is made within the kernel**.

Figure 1-1 shows how packets flow through the **nat** and **filter** tables within the kernel.

![packets_flow](/home/tux/Documents/firewall_notes/Linux_firewalls/chap01/packets_flow.png)

### 1.2.3 Matches

Every iptables rule has a set of matches along with a *target* that tells iptables what to do with a packet that conforms to the rule. **An iptables *match* is a condition that must be met by a packet in order for iptables to process the packet according to the action specified by the rule target**. 

Each match is specified on the iptables command line. The most import iptables matches for this book are listed below:

**--source (-s)** 					Match on a source IP address or network

**--destination (-d)**			Match on a destination IP address or network

**--protocol (-p)** 				

**--in-interface (-i)** 	Input interface

**--out-interface (-o)** 	Output interface

**--state** 				Match on a set of connection states

**--string** 				Match on a sequence of application layer data bytes

**--comment** 			Associate up to 256 bytes of comment data with a rule within kernel memory

### 1.2.4 Targets

Iptables supports a set of targets that trigger an action when a packet matches a rule. The most import targets used in this book are as follows:

**ACCEPT**			Allows a packet to continue on its way.

**DROP**			Drops a packet. No further processing is performed, and as far as the receiving 

​				stack is concerned, it is as though the packet was never sent.

**LOG**			Logs a packet to syslog

**REJECT**			Drops a packet and simultaneously sends an appropriate response packet (e.g., a

​				TCP Reset packet for a TCP connection or an ICMP Port Unreachable message for 

​				a UDP packet).

**RETURN**		Continues processing a packet within the calling chain.

## 1.3 Installing iptables

Because iptables is split into two fundamental components (kernel modules and the userland administration program), installing iptables involves compiling and installing both the Linux kernel and the userland binary.

Linux内核源码包含了Netfilter的许多子系统，基本的包过滤功能在一些内核发行版本中是默认开启的。

在内核2.6早期版本以及2.4版中，Netfilter编译选项默认是没有开启的。

虽然许多Linux发行版自带了编译好的iptables， 但从Linux内核官网下载的内核设置默认是没有开启的，所以并不是所有的Netfilter子系统都开启了。例如Netfilter connection-tracking功能直到内核的2.6.20.1版才默认开启。

在安装Linux内核前，需要下载并解压。对于2.6.20.1版本，可采用如下命令：

```bash
# 假定当前用户在/usr/src/目录下，且有相应权限
$ wget http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.20.1.tar.bz2
$ tar xfj linux-2.6.20.1.tar.bz2
$ ls -ld linux-2.6.20.1
```

# 1.4 Kernel Configuration

在进行内核编译前，需要构建kernel configuration file。

```bash
$ cd /usr/src/linux-2.6.20.1
$ make menuconfig
```

The `make menuconfig` command launches the Ncurses interface in which you can select various compile options. The Ncurses interface also easily lends itself to the configuration of a remote Linux kernel across an SSH session without having to forward an X Windows connection.

执行make menuconfig命令后，选择Networking->Networking Options - > Network Packet Filtering Framework

### 1.4.1 Essential Netfilter Compilation Options

Some of the more important options to enable within the kernel configuration file include Netfilter connection tracking, logging, and packet filtering. There are two additional configuration sections in the Network Packet Filtering Framework section -- Core Netfilter configuration and IP:Netfilter Configuration.

### 1.4.2 Finishing the kernel Configuration

### 1.4.3 Loadable Kernel Modules vs. Built-in Compilation and Security

本部分涉及的Netfilter大部分的子系统可以通过以下集中方式编译进内核：

- Loadable Kernel Module(LKM): 在运行时，可以动态的加入或者移除内核
- compiled directly into kernel:直接编译进内核，这意味着不能在运行时进行加载或移除模块

There is a **security trade-off between compiling functionality as an LKM and compiling directly into the kernel**. 一方面以LKM方式加入内核的任何特性的模块都可以通过`rmmod`命令将其从运行中的内核中移除。对于后期发现模块存在安全漏洞的场景，LKM方式更有优势。因为有些情况下漏洞是可以通过加载模块的方式缓解。并且，如果内核源码已经对漏洞进行了不定，则模块可以重新编译和部署甚至于在不停机的情况下完成，漏洞的修复可以实现zero downtime.

另一方面，如果被发现的漏洞代码已经直接编译到内核，漏洞修复的唯一方法是打补丁，重新编译，接着重启系统，但对于任务苛刻的系统(如集团级DNS服务器)，这种直接编译进内核的方式可能就不够灵活了。

以可加载的方式编译内核有潜在危险的可能。如果攻击者能成功的修改系统，就可能通过加载内核的方式植入内核级木马。这可能导致文件系统一致性检查工具崩溃，进程可以被隐藏，网络连接可以躲避`netstat` `lsof` 等工具的检查。Simply compiling the kernel without module support is not a foolproof solution, however, since not all kernel-level rootkits require the host kernel to offer module support. For example, the SucKIT rootkit can load itself into a running kernel by directly manipulating kernel memory through the `/dev/kmem` character device.

## 1.5 Security and Minimal Compilation

不管采用哪种编译Netfilter子系统的策略——LKM方式或直接编译进内核方式——在计算机安全中一个不可推翻的事实就是，系统越复杂，越不安全。越复杂的系统，越难做到安全。幸运的是iptables在运行时阶段和编译功能特性阶段都提供了极高的可配置性。

为了减小内核运行时代码的福再度，不需要的特性不要编译进内核。从内核移除不需要的代码可以最小化未发现漏洞的存在的可能性。比如，如果不需要logging support，simply do not enable the Log Target Support option in the menuconfig interface. 如果不需要跟踪FTP的连接状态，则不要启用FTP Protocol 选项。

## 1.6 Kernel Compilation and Installation

To compile and install the new 2.6.20.1 kernel within the `/boot` partition, execute the following commands:

```bash
$ make
$ su -
Password:
# mount /boot
# cd /usr/src/linux-2.6.20.1
# nake install && make modules_install
```

Assuming that you are using the **GRUB** bootloader and thatthe mount point for the root partition is `/dev/hda2` , add the following lines to the `/boot/grub/grub.conf` file using your favorite editor:

```bash
title linux-2.6.20.1
root (hd0,0)
kernel /boot/vmlinuz-2.6.20.1 root=/dev/hda2
```

Now, reboot!

```bash
# shutdown -r now
```

## 1.7 Installing the iptables Useland Binaries



